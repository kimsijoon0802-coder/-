<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Battle Royale (Single File)</title>
<style>
  html,body{height:100%;margin:0;background:#0b1220;color:#e6eef8;font-family:Inter,Segoe UI,Arial}
  #game{display:flex;flex-direction:column;height:100vh}
  header{padding:12px 18px;background:linear-gradient(90deg,#081026,#0b1428);display:flex;align-items:center;justify-content:space-between}
  header h1{font-size:18px;margin:0}
  #hud{padding:10px 16px;display:flex;gap:12px;align-items:center}
  #canvasWrap{flex:1;display:flex;align-items:center;justify-content:center}
  canvas{background:linear-gradient(#102233,#07121b);border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,.6)}
  button{background:#1f6feb;border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
  .small{font-size:13px;opacity:.9}
  #log{font-size:13px;margin-left:12px}
</style>
</head>
<body>
<div id="game">
  <header>
    <h1>Mini Battle Royale — 마지막까지 살아남아라!</h1>
    <div>
      <button id="restart">재시작</button>
    </div>
  </header>
  <div id="hud">
    <div class="small">체력: <span id="hp">100</span></div>
    <div class="small">남은 플레이어: <span id="remaining">--</span></div>
    <div class="small">시간: <span id="time">0</span>s</div>
    <div id="log" class="small"></div>
  </div>
  <div id="canvasWrap">
    <canvas id="c" width="900" height="600"></canvas>
  </div>
  <footer style="padding:10px 16px;font-size:13px;opacity:.9">조작: WASD 또는 화살표 이동 · 마우스 조준 · 클릭/스페이스 발사 · R 재장전</footer>
</div>
<script>
// Single-file Mini Battle Royale
// 플레이어는 원, 봇들이 움직이며 안전구역이 시간이 지날수록 줄어듭니다.
// 목표: 마지막 생존자가 되세요.

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const hpEl = document.getElementById('hp');
const remEl = document.getElementById('remaining');
const timeEl = document.getElementById('time');
const logEl = document.getElementById('log');

let keys = {};
let mouse = {x: W/2, y: H/2, down:false};
let lastTime = performance.now();
let elapsed = 0;
let gameOver = false;

class Entity{
  constructor(x,y,r,color){this.x=x;this.y=y;this.r=r;this.color=color;this.dead=false}
  dist(o){let dx=this.x-o.x, dy=this.y-o.y; return Math.hypot(dx,dy)}
}

class Player extends Entity{
  constructor(x,y){super(x,y,12,'#69f'); this.hp=100; this.speed=160; this.reload=0; this.maxAmmo=6; this.ammo=this.maxAmmo}
}

class Bot extends Entity{
  constructor(x,y,id){super(x,y,12,'#f66'); this.hp=40; this.speed=80 + Math.random()*40; this.id=id}
}

class Bullet{constructor(x,y,dx,dy,owner){this.x=x;this.y=y;this.dx=dx;this.dy=dy;this.owner=owner;this.speed=480;this.r=3}}

let player = new Player(W/2, H/2);
let bots = [];
let bullets = [];
let roundTime=0;
let safe = {x: W/2, y: H/2, r: Math.min(W,H)/2 - 20, shrinkInterval:8, nextShrink:8, minR:45};
let spawnCount = 8;

function spawnBots(n){bots = []; for(let i=0;i<n;i++){let x = Math.random()*W, y = Math.random()*H; if(Math.hypot(x-player.x,y-player.y) < 120){x += 140; y += 80} bots.push(new Bot(x,y,i+1));}}

function reset(){player = new Player(W/2, H/2); bullets=[]; elapsed=0; gameOver=false; roundTime=0; safe.r = Math.min(W,H)/2 - 20; safe.x=W/2; safe.y=H/2; spawnBots(spawnCount); updateHUD(); log('게임 시작!');}

document.getElementById('restart').onclick = reset;

function log(s){logEl.textContent = s; setTimeout(()=>{ if(logEl.textContent===s) logEl.textContent=''; },2500);}

window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()] = true; if(e.key === ' ') shoot(); if(e.key.toLowerCase()==='r') reload();});
window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()] = false});
canvas.addEventListener('mousemove', e=>{const rect=canvas.getBoundingClientRect(); mouse.x = e.clientX-rect.left; mouse.y = e.clientY-rect.top});
canvas.addEventListener('mousedown', e=>{mouse.down=true; shoot();});
canvas.addEventListener('mouseup', e=>{mouse.down=false});

function reload(){player.reload = 1.0; setTimeout(()=>{player.ammo = player.maxAmmo; player.reload=0; log('재장전 완료');},700)}

function shoot(){ if(gameOver) return; if(player.reload) return; if(player.ammo<=0){log('탄약 없음! (R로 재장전)'); return;} let ang = Math.atan2(mouse.y - player.y, mouse.x - player.x); let dx = Math.cos(ang), dy=Math.sin(ang); bullets.push(new Bullet(player.x + dx*18, player.y + dy*18, dx, dy, 'player')); player.ammo--; }

function updateHUD(){hpEl.textContent = Math.max(0,Math.round(player.hp)); remEl.textContent = 1 + bots.filter(b=>!b.dead).length; timeEl.textContent = Math.floor(elapsed);
}

function step(dt){ if(gameOver) return;
  elapsed += dt; roundTime += dt; // safe zone shrink logic
  if(roundTime > safe.nextShrink){ safe.nextShrink += safe.shrinkInterval; safe.r = Math.max(safe.minR, safe.r - 60); log('안전구역 축소!'); }

  // Player movement
  let moveX=0, moveY=0; if(keys['w']||keys['arrowup']) moveY=-1; if(keys['s']||keys['arrowdown']) moveY=1; if(keys['a']||keys['arrowleft']) moveX=-1; if(keys['d']||keys['arrowright']) moveX=1;
  if(moveX||moveY){ let len=Math.hypot(moveX,moveY); moveX/=len; moveY/=len; player.x += moveX * player.speed * dt; player.y += moveY * player.speed * dt; }
  player.x = Math.max(8, Math.min(W-8, player.x)); player.y = Math.max(8, Math.min(H-8, player.y));

  // Bots AI: move toward player or center of safe zone if outside
  bots.forEach(bot=>{ if(bot.dead) return; let target = player; // prefer player
    let ang = Math.atan2(target.y - bot.y, target.x - bot.x);
    bot.x += Math.cos(ang)*bot.speed*dt; bot.y += Math.sin(ang)*bot.speed*dt;
    // chance to shoot
    if(Math.random() < 0.01 + dt*0.02){ let dx = Math.cos(ang), dy=Math.sin(ang); bullets.push(new Bullet(bot.x + dx*16, bot.y + dy*16, dx, dy, bot)); }
  });

  // Bullets
  bullets.forEach(b=>{ b.x += b.dx * b.speed * dt; b.y += b.dy * b.speed * dt; });
  // remove bullets offscreen
  bullets = bullets.filter(b=>b.x>-20 && b.x<W+20 && b.y>-20 && b.y<H+20);

  // Collisions: bullets -> entities
  bullets.forEach(b=>{
    if(b.owner === 'player'){
      bots.forEach(bot=>{ if(!bot.dead && Math.hypot(bot.x-b.x, bot.y-b.y) < bot.r + b.r){ bot.hp -= 20; b.x = -999; if(bot.hp <=0){ bot.dead=true; log('적 처치!'); } }
      });
    } else { // bot bullet
      if(!player.dead && Math.hypot(player.x-b.x, player.y-b.y) < player.r + b.r){ player.hp -= 12; b.x = -999; if(player.hp<=0){ player.dead=true; gameOver=true; log('당신이 사망했습니다...'); }
      }
    }
  });

  // Melee collision: bots touching player
  bots.forEach(bot=>{ if(bot.dead) return; let d = Math.hypot(bot.x-player.x, bot.y-player.y); if(d < bot.r + player.r){ // damage over time
      player.hp -= 20 * dt; bot.hp -= 10*dt; if(bot.hp<=0) bot.dead=true; if(player.hp<=0){ player.dead=true; gameOver=true; log('당신이 사망했습니다...'); }
    }
  });

  // Safe zone damage
  let dToSafe = Math.hypot(player.x-safe.x, player.y-safe.y);
  if(dToSafe > safe.r){ player.hp -= 12 * dt; }
  bots.forEach(bot=>{ if(!bot.dead){ let db = Math.hypot(bot.x-safe.x, bot.y-safe.y); if(db > safe.r) bot.hp -= 8 * dt; if(bot.hp<=0) bot.dead=true; }});

  // Check win condition
  let aliveBots = bots.filter(b=>!b.dead).length;
  if(!player.dead && aliveBots === 0){ gameOver=true; log('축하합니다 — 당신이 최후의 1인이 되었습니다!'); }
  if(player.dead){ // reveal remaining winner
    if(aliveBots>0) log('게임 종료 — 다른 플레이어가 승리했습니다.');
  }

  updateHUD();
}

function draw(){ // background
  ctx.clearRect(0,0,W,H);
  // safe zone
  ctx.save(); ctx.beginPath(); ctx.fillStyle = 'rgba(60,120,200,0.06)'; ctx.strokeStyle = 'rgba(60,140,220,0.22)'; ctx.lineWidth=2; ctx.arc(safe.x, safe.y, safe.r,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore();

  // bullets
  bullets.forEach(b=>{ ctx.beginPath(); ctx.fillStyle = '#ffd'; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); });

  // bots
  bots.forEach(bot=>{ if(bot.dead) return; ctx.beginPath(); ctx.fillStyle = bot.color; ctx.arc(bot.x,bot.y,bot.r,0,Math.PI*2); ctx.fill(); // health bar
    ctx.fillStyle='#222'; ctx.fillRect(bot.x-14, bot.y-20,28,5);
    ctx.fillStyle='#8f8'; ctx.fillRect(bot.x-14, bot.y-20, 28 * Math.max(0,bot.hp/40), 5);
  });

  // player
  ctx.beginPath(); ctx.fillStyle = player.dead ? '#555' : player.color; ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
  // player barrel
  let ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  ctx.beginPath(); ctx.moveTo(player.x,player.y); ctx.lineTo(player.x + Math.cos(ang)*18, player.y + Math.sin(ang)*18); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();

  // UI overlays
  ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fillRect(8,8,160,60);
  ctx.fillStyle='#fff'; ctx.font='13px sans-serif'; ctx.fillText('체력: ' + Math.max(0,Math.round(player.hp)), 16, 28);
  ctx.fillText('탄약: ' + player.ammo + (player.reload? ' (재장전...)':''), 16, 48);

  // mini scoreboard
  ctx.fillStyle='rgba(0,0,0,0.22)'; ctx.fillRect(W-170,8,160,72); ctx.fillStyle='#fff'; ctx.font='12px sans-serif'; ctx.fillText('남은 적: ' + bots.filter(b=>!b.dead).length, W-160, 28);
  ctx.fillText('시간: ' + Math.floor(elapsed) + 's', W-160, 48);

  if(gameOver){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(W/2-160,H/2-60,320,120); ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.textAlign='center'; if(!player.dead) ctx.fillText('승리! 최후의 생존자입니다!', W/2, H/2-12); else ctx.fillText('패배...', W/2, H/2-12); ctx.font='14px sans-serif'; ctx.fillText('재시작 버튼을 눌러 다시 플레이하세요', W/2, H/2+18); ctx.textAlign='start'; }
}

// Main loop
function loop(now){ let dt = Math.min(0.05, (now - lastTime)/1000); lastTime = now; step(dt); draw(); requestAnimationFrame(loop); }

reset(); requestAnimationFrame(loop);

// small helper: allow auto-fire when holding mouse
setInterval(()=>{ if(mouse.down) shoot(); }, 180);

</script>
</body>
</html>
